I have been actively using leetcode as a platform to prepare for interviews for over 4 months now, and I feel I have learnt a few things along the way, that might or might not be useful for the other person looking for some direction, and getting a clear idea of how to progress on this journey.

[EASY]

If you are just starting off, starting from easy problems is the best way to get in touch with your coding skills again, and/or build up new ones.
As mentioned by other users, it’s better to have a breadth-first approach to easy problems. Pick 5-6 questions from each topic and try to master the basics of the topic.I did a depth first of all the easy ones but looking back I feel it’s better to move to the next topic once you feel confident in one.
The purpose of the easy questions is to ingrain the basic concepts of a particular data structure or algorithm and if you look closely you will find a lot of questions asking for solutions testing your ability/understanding of language syntax, data structure core basics,etc, basically the “dirty” work, we so often don’t give due attention. Leverage the same and get your hand dirty.
You will also find a healthy mix of the use of two-three data structures or algorithms in some problems. Look for such problems, for they are a great way to test your understanding of how more than one DS work together to build a beautiful solution.
That being said, I would recommend moving from the “easy” phase as soon as possible, for its the mediums that will be asked mostly in interviews.
Must-do Easy questions [ Download the list here ] :
13. Roman to Integer
20. Valid Parentheses
21. Merge Two Sorted Lists
141. Linked List Cycle
155. Min Stack
169. Majority Element
202. Happy Number
204. Count Primes
242. Valid Anagram
371. Sum of Two Integers
88. Merge Sorted Array
108. Convert Sorted Array to Binary Search Tree
189. Rotate Array
205. Isomorphic Strings
226. Invert Binary Tree
448. Find All Numbers Disappeared in an Array
572. Subtree of Another Tree
557. Reverse Words in a String III
589. N-ary Tree Preorder Traversal
605. Can Place Flowers
617. Merge Two Binary Trees
665. Non-decreasing Array
669. Trim a Binary Search Tree
674. Longest Continuous Increasing Subsequence
703. Kth Largest Element in a Stream
705. Design HashSet
852. Peak Index in a Mountain Array
1160. Find Words That Can Be Formed by Characters
[MEDIUM]

Once you feel confident enough with the basics, you can move onto the medium ones. Medium problems are pivotal in interview preparation since any decent interview will have at least one instance of medium problems. Moreover some of the advanced data structures and algos like graph, backtracking, dynamic programming are not well covered in the easy section, so the medium problems are a good stop to learn them.
Again, breadth-first approach works wonder in this case as well. Pick like 10 problems from each topic, try to solve them to the best of your capabilities and practise of easy problems, and if you find it difficult to solve at first, take help from the discussion forum.
What's important to note is the purpose of you doing N number of problems, should solely be to learn new techniques, be able to apply the learnt technique in similar problems later, and learn the basics of advanced data structure that you might have missed in the easy section.
It's normal to not be able to solve medium level problems at first. Don't feel bad about taking help from the discussion forum, but try to learn the techniques as much as you can.
Do not cram the solution. There is no point hoping you will remember the solution in an actual interview, because in a pressure situation it's not advisable to rely just on your memory. Rather place your bets on your acquired skills.
While you are solving questions of a particular topic, make sure to give the theory a good read before or during the process of solving questions. It's important to know the basics of implementations of various data structures and algorithms like graph traversals, backtracking, memoization, trees, binary search etc. There are various resources available online for the same.
Once you feel fairly confident after say, 60-70 mediums, it's always a good idea to start giving contests. Contests not only simulate the actual interview scenarios by having a time constraint, they also test your ability to be able to come up with solutions on your own without taking help from any other resources.
Keep looking at better solutions posted by other users, compare your solution with them in terms of time and space complexities, know when to make the tradeoff between the two and ask for help whenever you feel stuck. Be open to learning and the rest will fall in place.
A comprehensive list of must-do medium problems [ Download the list here ]:
5. Longest Palindromic Substring
11. Container With Most Water
17. Letter Combinations of a Phone Number
22. Generate Parentheses
33. Search in Rotated Sorted Array
34. Find First and Last Position of Element in Sorted Array
46. Permutations
24. Swap Nodes in Pairs
48. Rotate Image
49. Group Anagrams
56. Merge Intervals
75. Sort Colors
94. Binary Tree Inorder Traversal
102. Binary Tree Level Order Traversal
106. Construct Binary Tree from Inorder and Postorder Traversal
117. Populating Next Right Pointers in Each Node II
142. Linked List Cycle II
150. Evaluate Reverse Polish Notation
151. Reverse Words in a String
166. Fraction to Recurring Decimal
179. Largest Number
200. Number of Islands
207. Course Schedule
208. Implement Trie (Prefix Tree)
215. Kth Largest Element in an Array
236. Lowest Common Ancestor of a Binary Tree
300. Longest Increasing Subsequence
328. Odd Even Linked List
338. Counting Bits
347. Top K Frequent Elements
355. Design Twitter
417. Pacific Atlantic Water Flow
421. Maximum XOR of Two Numbers in an Array
424. Longest Repeating Character Replacement
454. 4Sum II
529. Minesweeper
525. Contiguous Array
658. Find K Closest Elements
763. Partition Labels
767. Reorganize String
1171. Remove Zero Sum Consecutive Nodes from Linked List
[Other points to note]

Leetcode is a wonderful community to learn, discuss and find support in others going through the same process. Leverage it.
Don't shy away from being a part of discussions, ask for help, or ask questions from others just because you feel it sounds stupid.
Constantly read articles on Leetcode, not only related to solutions but interview experiences, problems faced during the process etc. You can benefit so much from learning about stories of others here and also derive a sense of belonging to the whole process.
Make notes of all what you have learnt from a question, a trick or techinque for these will be handy when you will need to revise.
It's okay to feel lost, confused or difficult to solve questions at times. Some questions are harder than others, some are trickier and some have no solid pattern to them. Don't get intimidated by the process. With time and practise everything gets better. Have patience and don't lose hope.

Must Do Easy Questions

https://leetcode.com/problem-list/xix1yu51/

Must Do Medium Questions

https://leetcode.com/problem-list/xixy4dq7/





https://leetcode.com/discuss/post/449135/how-to-effectively-use-leetcode-to-prepa-m7gt/

************


Trying to make a short, complete and realistic DSA study guide for coding interviews as well as competitive programming. Studying for competitive programming is quite vast, so we will try to focus more on coding interviews as well as some overlapping study materials for competitive programming. Study materials depend mostly on the position you are looking for, say for example, i have seen people been asked on rope data structure, hopcroft-karp algorithm, max-flow algorithm, hungarian algorithm etc. others non trivial stuffs. Though those are for L4 or L5 positions and DSA matters less there(System design does). So it depends. In this study materials guide we will be writing for mostly entry level or at most 1 or 2 level up from entry (FAANG mostly).

I won't give a massive list of video links for each topic rather it will be short and concise with some tips, so that one can finish this guide within a reasonable amount of time. And i will try to categorize topics so that one can find his/her weakness easily and use this guide to work on it. And remember Only Practice can give you a sense of completeness for a specific topic. And Don't Rush. Enjoy the journey. Try to be a natural problem solver not a interview acing problem solver. And you are not alone! Keep moving mate, never ever dare to give up. Hard work is going to pay you off very soon.

N.B: CI = Coding Interview, CP = Competitive Programming, DSA = Data Structure and Algorithm, LC = LeetCode, CLRS = Cormen, Leiserson, Rivest, and Stein, BFS/DFS= Breadth/Depth First Search, DP = Dynamic Programming.

Here is a Straightforward Study Guide PDF if you don't have time to read whole article. PDF contains only links to study materials. But i will highly recommned you to study the article first and then use the PDF.

Link for PDF: Comprehensive Data Structure and Algorithm Study Guide PDF Format
Preview of the Study Guide:
Comprehensive Data Structure and Algorithm Study Guide Preview


Time Complexity
Video no. 1-16 Abdul Bari's Algorithm Playlist

Comment: After watching this 16 videos i can guarantee that you will gain mastery on Time Complexity for sure.
Data Structure
Data Structures Easy to Advanced Course - Full Tutorial from a Google Engineer and ACM ICPC World Finalist.

Comment: This is one of the best materials to study on data structure topic. William implemented each on Java. But it doesn't really matter which language you use, i did this course in both in c++ and python. And try to code yourself after watching a data structure topic and do some leetcode question on that. And this is all you need to ace DS questions.
Algorithms
The Major Five topics are:-
Ad hoc/ Implementation Problems
Programming Paradigm(Greedy, backtracking, branch and bound, DP, Divide and Conquer, Brute force etc.)
Graph Theory(directed, undirected, weighted, rooted(IN & OUT) and unrooted tree, DAG etc.)
Math(Number theory, Computational Geometry, Combinatorics, Linear Algebra etc.)
Others(String Processing, Bit Manipulation etc.)
Implementation Problems
Practice, Practice and Practice! Besides LC try to do some problems on other platforms for this. Again for this type, only practice can guarantee success. And that's it.
Programming Paradigm
Now, this is a huge deal for all of us, right?. So many topics to cover. But if you look closely the basic to ace this paradigm based question is Recursion. So before even try to understand DP, D&C etc. Understand Recursion and then come back. Recursion is the open secret tool to ace this type.

Best materials for recursion
Recursion Playlist by mycodeschool and video no. 18 to no. 29 from Abdul Bari's Algorithm Playlist to understand Masters Theorem for the proof of recursion.
And another super important thing on recursion is to understand types of recursion like tail, head, nested, tree(the one you need everywhere) etc. You can study from sparknotes tutorial on recursion types or may follow a textbook. I will strongly recommend to study and master Chapter 4 | Divide and Conquer | Page No.65 from Introduction to Algorithm by CLRS. You have to spend sufficient time to understand recursion through studying and practicing, as recursion is will be the base of everything in this type.

Some Notes on recursion: Almost everyone knows what recursion is, right? But that is not enough. You have to create some sort of mental model how recursion actually saves states by pushing function code to stack and reaches at the last/smallest problem and then solves it and then backtrack from there by poping function code from stack to top and etc. Hope those materials above will clarify everything.

Now about studying each topic of Programming Paradigm:

Divide and Conquer
Implement merge sort, segment tree, binary search etc. And study Video no. 18, 33 to 38 from Abdul Bari Algorithm's Playlist

Greedy
This is tough one. Proofing greedy algorithm is quite difficult. Studying known problems like knapsack, job schedule, optimal merge pattern, Huffman coding etc are enough to ace greedy questions. Study Video no.39-no.45 from Abdul Bari Algorithm's Playlist

Backtracking & Branch and Bound
Study Video no.63 to no.71 from Abdul Bari Algorithm's Playlist. This topic is the key ingredient to solve Dynamic Programming questions.

Dynamic Programming😭
The big guy enters! After watching some top problem solver's code i get too much frustrated. They came up with all this sub problem based formula and solves it like a beginner question(Just kidding! they don't. It's because of their years of practice to recognize the pattern/formula for a dp problem). Say for example: A String based DP problem involves a 2D matrix where [i][j] generally refers to the solution for index i to j of the String and etc. Here is what you should do, try to understand backtracking very well as that will be the key in solving DP. After getting a backtracking solution you can memoize the previous solutions and reduce solutions to 2/3 Degree Polynomial Time. By the way, there is a good news for Pythonistas. After you just come up with a 2N backtracking solution just use functools.lru_cache(maxsize=None) decorator and you will have a dp solution(almost 90% time). More info here at:-

What is memoization and how can I use it in Python?

Anyway, you have to study known DP problems as much as you possibly can and try to recognize the patterns and types. Here is the post that will do that for you:-

Leetcode Coin(giveaway) winning post on Dynamic Programming Patterns by aatalyk.

Study and solve all questions from here. Just stick with it till the last question of this article. And when studying the article try to follow:-

Tushar Roy's Dynamic Programing Playlist and Video no.46 to no.60 from Abdul Bari Algorithm's Playlist.

I find Abdul bari's tutorial more effective and easy to follow. His style to teach students is quite exceptional. Suppose you are studying Longest Common Subsequence, first understand the question really good -> try to solve a small problem of the main problem -> try to solve a bit big problem with the help of solution and see if you can find any formula/pattern -> if you can't find any then read discussion/solution(only algorithm not code) and try to code it up after understanding -> If still doesn't work for you then watch the video of that topic from the playlist i have mentioned and try hard this time to understand and visualize the algorithm. -> You solved a DP Question! Yahoo!.

Now one of the most important study material for DP. How many of us know that a dynamic programming is nothing but a topological sort of problem dependency directed acyclic graph which means if you can generate a test case for a DP problem that has a cycle then that DP solution will fail for that cyclic graph. To know all of this cool things and understand DP really good then study:-

video no.19(MUST MUST!),20-22,26-27,39-45 from MIT OCW Introduction to Algorithm

and this will be enough!
Graph Theory
Graph Theory Easy to Advanced Course - Full Tutorial from a Google Engineer and ACM ICPC World Finalist

Comment: There are so much overlaps in between greedy, dp with graph theory. Say for example Dijkstra, Prim's and Kruskal's Minimum Spanning tree are just Greedy Algorithms or backtracking is just DFS with branch pruning with condition. So you will find it a lot easier after studying programming paradigm section. In fact graph problems are either so easy to recognize that everything is given so explicitly that any one can recognize it as a typical graph question or may be it's too hidden to even think it as a graph question. So my suggestion is to think out of the box for a problem, think if a problem can be solved by using graphs. Never forget that, Interviewers are just obsessed with binary tree, so try to solve as many questions as you can related to tree, specifically binary tree(and also n-ary tree). And also solve at least 20 questions with tag BFS and DFS in Leetcode which will definitely boost your tree and graph problem solving skill as graph traversal is the main toolkit to solve tree/graph problems in interview. That's all about graph.
Math
Math is fun, Math is everywhere and Math can win you any war from coding interview to WW2(Remember Alan Turing and enigma!). Math problems are more common to competitive programming environment. Sometimes interviewers will ask you for proof by induction or contradiction for a problem. And even if they don't and you can show the proof it will be a huge boost to your success. The best material to study:-

MIT 6.042J Mathematics for Computer Science, Spring 2015 and also try to examine your understand through their quiz and exams from Mathematics for Computer Science MIT OCW main site.

And CP(or may be CI) guys must read the Algebra Section from here:-

English translation of e-maxx awesome algorithm text tutorial.

This will be enough for the math topic at least for Coding Interviews. But may be not enough for CP guys.
Others
1. String Processing: Follow the string section from CP Algorithms Site.
2. Bit Manipulation: Follow HackerEarth Bit Manipulation Tutorial and also Fun with Bits Tutorial.
[Comment if you have any other topic in mind]
Nota Bene(N.B): I didn't cover the study materials for advanced DS like SegTree, Fenwick tree/ BIT, Sparse Matrix etc. And also some non trivial algorithms. Don't worry about these, you won't face them in an interview in 95% case at least for entry levels or a bit higher from entry. But if you are studying for CP, good luck, just study everything you see on the fly.😛 And you might have seen i tried to categorize CI and CP guys as to differentiate the volume of study materials for each of them.
Tips:
 While 1:
	print("Deliberate Strategic Practice")
	print("Study and implement New DSA")
	print("Simulate real environement and test yourself") # do contest, contest and contest
and its cliché i know! But it's the only way. There is no secret sauce really. Suppose you just read backtracking from an article or may be a video, then why not solving 10 DFS and Backtracking tagged question in LC at a stretch ?. In university, i saw my classmates and seniors with no cs knowledge became red coder in CP platforms within ~1-2 years. Their secret is nothing but Regular Deliberate Strategic Practice. They always try to solve questions beyond their comfort zone and do it regularly. And that is it really. Always solve questions that you are not comfortable with, push yourself. Try to solve topic wise after you get a good general grasp of DSA. Find your weakness and work on it. Hard work will pay you off one day.
Other comprehensive CI (and CP) prep guides: (Comment if you know any good material)
CP and CI Study materials by Jasmine Chen(Google SWE). This whole write up would be incomplete without this link.
Ultimate Guide to Interview Preparation by a Competitive Programmer (Gold Mine!)
Tech Interview Guide (This one is just gold!)
Great guideline on acing interviews and what to study?
DSA for CP guys(CI guys should also try if you have time)
Just want to finish with one of my favorite quote by Mark Manson:

""I wanted the reward and not the struggle. I wanted the result and not the process. I was in love not with the fight but only the victory. And life doesn't work that way.""

Hope this will help you a bit to ace your next coding interviews or competitive programming contest. Any suggestions on improving materials or adding materials will be highly appreciated.

Thank you guys. I am from non CS background(studying Materials Enginnering as Major at Uni) and don't feel bad if you are also from non CS background as end of the day your curiosity and persistance is all it matters. I am quite new to this platform(CI platform to be specific) and more used to CP platforms. You guys are the best community i have ever seen. Cheers! Happy Acing Interviews!

![image](https://github.com/user-attachments/assets/ce25b391-d42f-404d-99fd-c49f779c8c40)

https://leetcode.com/discuss/post/494279/comprehensive-data-structure-and-algorit-tdez/

******

Disclaimer and proviso: “The postings on this site are my own and don’t represent Amazon’s position in any way whatsoever”.

Have you ever failed a code-intensive technical interview? I have, and can 100% relate. It was one of the most embarrassing moments of my professional career. It happened once, because I got complacent, didn’t put in the prep time, and took the fact that my professional experience and ability to code would carry me through.

What a colossal mistake that was. I remember struggling in front of the white board for two hours and walking out of the interview dejected, knowing I missed out on a great opportunity due to a false sense of security and arrogance, and lack of preparation. I swore I would never let it happen again, and it hasn’t.

Thus, what’s contained here is my own blueprint, from having participated in technical interviews with many software companies of note, and from conducting literally hundreds of technical interviews at companies I work(ed) for. This methodology has also been refined with the help of other experienced Engineers and seasoned technical interviewers. Follow this, and you will absolutely crush most code-intensive tech loops (yes, this means Amazon, Apple, Facebook, Google, Microsoft ☺) as well as most other software companies out there.

In writing this, some will ask if I’m giving away the equivalent of state secrets. The answer is a resounding “No”. Nowadays, most technology companies provide very comprehensive instructions via email or other means prior to the interview containing a lot of this material — some getting to very granular levels of detail. For example, here is a snippet from an email sent out by a very prominent software company to their Engineering candidates:

Technical Preparation
Portions of the interviews will be extremely technical revolving around theory, algorithms, data structures, design patterns, languages, etc. I can’t stress enough the value of studying for the interview as it can be very much like a CS exam, and its randomness around topics can catch folks by surprise.

The email then goes on to list blog posts, books, videos, and other study materials, and includes 4 attachments with explicit instructions on what to study for.

Why would any company do this, you ask? Because the fail/pass ratio for technical interviews is extraordinarily high (on average, over 90% fail), and companies want well-prepared candidates. Interviewing 100 people and hiring 10 is not an efficient use of anyone’s time. Hiring takes a lot of time, and every company wants to do better.

OK. So with all of this material available on the Web and elsewhere, why are so many folks out there still bombing technical interviews? Simple. From my experience, and in speaking to countless colleagues in technology that are highly experienced interviewers, one thing is patently clear: Engineers of all types and educational backgrounds either passed or failed the tech screens and coding loops due to a simple root cause: preparation or lack thereof. So let’s address and fix that, right now.

Assumptions
First and foremost, you already know how to code. You may or may not have a CS background — this is OK, but you’re already a good coder, you just need a CS refresher, and a game plan for interview day.

This will cover the general coding interview blue-print. Candidates are, of course, expected to study and be prepared for technology specific questions around areas such as UX/UI development, embedded systems, mobile devices, etc.

How long do I need to prepare?
Your mileage may vary, but in general, at least 4–6 weeks, for 2–3 hours a day, and this assumes you are an experienced Engineer with a strong background in Computer Science. Move the time slider out according to your experience level.

The Basics
First, the good news. Virtually all software companies, especially the large ones, use the same interview process (in many cases to a great degree of similarity). We won’t cover the process here, but these 3 blog posts cover what you should expect to encounter in 90% or more of your technical interviews at most companies:

“Get that job at Google” — Steve Yegge. The original article, and by far the best reference on the topic
“Get that job at Facebook” — Carlos Bueno
“Get that job at Microsoft” — Nick Ciubotariu (shameless plug)
If you only read one article, read the first one. Then read it again. It’s must know for anyone who will go through a code-intensive technical interview, now or in the future.

Now, the irritating news. The articles are great, but also broad. That’s a ton of material to cover. And they just tell you to study everything. And it gets worse. In Computer Science, there are an infinite amount of questions that can be asked. So we need specifics.

What to Study
First, the absolute must-haves, in order:

Trees (especially Binary Search Trees)
Trees (especially Binary Search Trees) — again
Big O Notation
Hash Tables
Object Oriented Design/Systems Design
Algorithms: Breadth First Search/Depth First Search, Binary Search, Merge Sort and Quick Sort
Let’s dispose of Captain Obvious (Trees, and specifically, BST’s). In every interview I’ve been through, with any team, product group or company, I’ve gotten a Binary Tree or BST question. Every single one. I have also been through interviews where every single one of the interviewers asked a BST question.

Speculating on reasons for this is neither here nor there. Personally, I posit that it’s due to the versatility of Binary Search Trees — Insertion, Deletion and Search all take O(log n) time on average, and O(n) time worst case. They are very elegant data structures with lots of practical applications in Software Engineering, which is why, in any technical interview, you’re going to see a BST-related question.

The rest of the study topics are self explanatory. Big O notation is absolutely necessary — you will be asked to determine time/space complexity in almost all your interview questions, and how to optimize your code for better time/space complexity. You are almost guaranteed to be given time/space complexity guidelines for designing your code. You are extremely likely to see a question where the solution will involve the use of hash tables. You are guaranteed to see at least one OO Design question. And you are guaranteed at least one algorithmically driven question.

So what’s left? Again, in order of priority:

Arrays
Recursion
Linked Lists
Stacks/Queues
Bit Manipulation
You will want to know recursion (remember the termination clause!!) and linked lists. Same for Stacks and Queues. Questions involving bit manipulation are rare but are encountered from time to time.

Mock interview guidelines
Use a white board, or better yet, pencil and paper. Follow this rule, and you’ll be successful. Violate it at your own peril.

In an interview setting, you will not be given the advantage of using an IDE and compiler, so prepare in the most realistic way possible. Thus, write down the interview question in the same way that an interviewer would be providing it to you. Break it down into small parts and an approach to solve the problem. Write some pseudo-code, then write real code. Do all of this on paper, “walking through the code” as you write it. See if you can find bugs in the code (they will be there). Test your code. Pay attention to nullchecks and corner cases. Take your time and really understand the problem, before you move on to the next one.

Using this approach ensures you will learn and internalize the subject matter, rather than commit certain coding questions and solutions to rote memory. Run a coding question through an IDE only when you feel like you have given it your best shot and have exhausted the solution on paper. Writing the question on paper has an added advantage — you can review it later.

Eat the elephant one bite at a time (how to study)
The topic of computer science is, by its very own nature, very dense, and the subject matter can be hard to digest. Pick a particular area, increasing the difficulty as you go, and try to solve 2–3 coding questions per day. Anymore than this, and you may start to lose your drive to study, begin skipping days, etc., and a good study plan will immediately unravel.

Dedicate one day to reviewing that week’s questions and study topics. This is extremely important for material retention. Take one day off per week to give your brain a break. This is important, everyone needs to rest and reset.

Let’s say you devote 6 weeks to interview preparation. At 6 days per week, with 1 day dedicated to review (leaving 5 days a week for coding questions), you’re going to solve 60 questions (assuming 2 questions/day), or 90 questions (assuming 3 questions/day). That’s pretty serious progress, and 6 weeks will go by in a blur! Again, dial the time up or down as needed.

Don’t cram, unless absolutely necessary! Re-read the section on properly preparing if needed☺. A crash course will yield marginal results at best, failure at worst.

The week before the interview
If you followed the blueprint above, you’re not cramming this week. You may be reviewing study material, but mostly you’re doing additional research on the company you’re interviewing with, the team, culture fit, and position in general. You already put in the study sweat equity. Use this week to spend the time polishing other areas of the interview, such as soft skills, specific technology topics, etc.

The day/night before the interview
Rule #1: get a good night’s sleep!! Nothing is more important than being at your best for what promises to be a very exhaustive day of programming acrobatics. You’ve done your homework and you’re ready — have confidence in yourself and the hard work and prep time you’ve put in to get here!

Do not violate this rule unless a work/family emergency dictates otherwise. And if this rule is broken for subsequently-mentioned reasons, it is probably wise to postpone the interview. This happens more frequently than you think, and folks will understand.

No, no and no ☺
Do not interview while you’re sick!! It’s not only not good for your own personal sake of well being, no one wants you there to get them sick! I admit to having done this once — I was on the verge of pneumonia, and my interviews had to be halted and I had to be helped out of the building as I was about to pass out from dehydration. Thankfully, I interviewed with a very understanding and courteous company who offered me another chance to come on campus and interview once I was healthy again.

The day of the interview
Be on time and bring a bottle of water (I prefer Gatorade for energy). Most companies will offer you refreshments, but have something handy just in case.

Relax and listen closely. When you engage your interviewer after a coding question has been given to you, do not start coding right away! Ask clarifying questions — this is absolutely expected. For instance, you may be asked a question such as “Delete the nth to last item from a list”. Would you start coding this immediately? I posit that you really couldn’t — here are clarifying questions that I would ask prior to formulating an attack vector or designing an algorithm to solve the problem.

What type of list are we discussing? “A linked list”
Is this a singly-linked list or doubly-linked list? “Singly-linked list”
Is space complexity important? “No, but time complexity is”
In that case, is a recursive solution acceptable? “Yes, but it would be nice to see an iterative solution as well if we have time”
Do you want me to code the helper Node class? “No, you can assume you have int data and Node next”
We now have a completely different question than we started with. “Delete the nth to last node from a singly-linked list”. Since the interviewer isn’t concerned with space complexity, we can use an elegant and simple recursive solution to start with (recursive calls normally incur a penalty from a space complexity perspective, since recursive calls are stored in the execution stack, with the exception of tail recursion). We know that the interviewer doesn’t care about the Node class, and wants an iterative solution as definite bonus points.

Always solve the problem algorithmically first. Talk through your approach to the problem with the interviewer. Draw out a small sample set of data to serve as a guide. Write a bit of pseudocode, in step fashion, explaining each step. Then, begin to write real code. Talk through the code — it helps you think on your feet and formulate your thoughts as you go. Test your code against the data set you created (your interviewer will want you to “run” the code) anyway, so take the initiative and do so. Ask the interviewer if they would like for you to write test cases if there is time, and be prepared to do it if asked to; this will earn you major bonus points as most candidates do not do this.

What to do if you’re stuck
Always solve the problem algorithmically first. If your algorithm is solid, coding it will be easy. If you get stuck on coding, code your skeleton functions and get the nullcheck/termination clauses and other test cases out of the way to start getting code flowing in the right direction (or at least getting some code on the whiteboard).

Ask for help if you’ve exhausted your train of thought. You may get docked a few points, you may not. A critical factor in assessing Engineers is how they collaborate with others, and it sure beats staring at a white board in silence. The interviewer won’t solve the problem for you, but they will provide hints if needed, this is done very frequently. Build on the hints, and break down your problem into small pieces. Try various solutions, and don’t be afraid of the brute force approach — you can optimize it later if needed.

Additional pointers
Use the whiteboard judiciously. Start at the top left and work your way down, then right. Write as legibly as possible. Clearly separate pseudo-code from real code. Use generally-accepted coding conventions (in Java, for instance, method names have mixed case letters, beginning with a lower case letter and starting each subsequent word with an upper case letter). Make sure your parentheses and brackets are balanced, and you’re not missing a sea of semicolons in your functions. Stay away from one letter variable names if possible; of course, this excludes loop constructs (int i, j) and try/catch blocks (exception e). Loop counters always start with i for index.

In other words, ensure you’re writing clean, compilable code — this is definitely expected of you, and you will get demerits for sloppy code.

Be sure to take at least one break. I’ve been through an interview with 7 interviewers on the panel where a bio break wasn’t offered. Ask for one if needed. Stay hydrated and stay positive.

And most important, relax and show confidence throughout the interview. Treat this as a situation where you are meeting new people and making some new friends, with some fun challenges thrown in the mix, not a do-or-die pressure-cooker.

To add: If you have one bad interview round, shake it off immediately. Put it in the back of your mind and absolutely kill the others. It is very, very rare that candidates go through the entire interview process having aced every single session. Your hire decision will depend on the data points from everyone you interview with, which is why you’ll have multiple coding sessions. One sub-par session won’t necessarily sink you (and indeed, most of the time it does not, if the others are positive).

Study Guides
(for clarity, I have no affiliation with anyone or anything I will recommend in this article, and will receive zero compensation for the recommendations I make). These are, in my opinion, just great resources to help you along the way.

Books:

Cracking the Coding Interview: 150 Programming Questions and Solutions — to date, there is not a better book out there for technical interview preparation
Interactive Learning:

My Code School — One of the best resources I have found that comprehensively covers data structures, algorithms and CS concepts in general. Best of all, it’s free!
Udemy — Data Structures and Algorithms. — For those unfamiliar, or those that need a good refresher. There is a cost for this course ($49)
Online Training:

Leetcode — With over 150 questions and counting, this should be your absolute first destination for practicing programming questions and code katas.
Useful Sites:

GeeksforGeeks — everything but the kitchen sink is here ☺, including a very nice “interview corner” section, and countless programming questions
careercup — Developed by the author of “Cracking the Coding Interview”, this site remains an invaluable resource to everyone looking to improve their technical interview skills
Improve and maintain, over time
Once the rust is gone, and you’re fully prepped, it is dead easy to keep your CS and interview skills sharp: solve one coding question per day. I’ve been doing this for the past 3 years or so, and I’ve realized the following benefits:

I’m never out of practice
It helps flex mental muscles and improve critical thinking, the same way solving crossword puzzles, brain teasers or playing a game of chess might.
The relative time investment is small — no more than 30–35 minutes per day, on average, and the benefit is immeasurable. Were I to find myself in an immediate technical interview need situation, for whatever reason, I am always well prepared.

If this article helps just one person nail their interview and get a hire decision, mission accomplished. I hope you enjoy the content below. Have fun studying, and good luck, wherever your technical career takes you!!

(cross-posted at booleanzen.com and LinkedIn.)

https://www.linkedin.com/pulse/20141120061048-6976444-ace-the-coding-interview-every-time/

https://medium.com/@nick.ciubotariu/ace-the-coding-interview-every-time-d169ce1fd3fc
